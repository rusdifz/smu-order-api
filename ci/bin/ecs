#!/bin/bash -e

update_task_definition() {
  ensure_params

  local image_repository
  local image_tag
  local new_image_name
  local task
  local current_container_definitions
  local new_container_definitions
  local new_task_definition
  local new_task_revision
  local args=()
  local service_task_count

  local -A register_task_def_args=( \
    ['task-role-arn']='taskRoleArn' \
    ['execution-role-arn']='executionRoleArn' \
    ['network-mode']='networkMode' \
    ['cpu']='cpu' \
    ['memory']='memory' \
    ['pid-mode']='pidMode' \
    ['ipc-mode']='ipcMode' \
    ['proxy-configuration']='proxyConfiguration' \
    ['volumes']='volumes' \
    ['placement-constraints']='placementConstraints' \
    ['requires-compatibilities']='requiresCompatibilities' \
    ['inference-accelerators']='inferenceAccelerators' \
    ['runtime-platform']='runtimePlatform' \
  )

  image_repository=$DOCKER_REGISTRY/$IMAGE_NAME

  if [[ -z "$VERSION" ]]; then
    image_tag=latest
  else
    image_tag=$VERSION
  fi

  new_image_name="${image_repository}:${image_tag}"

  register_task_definition

  new_task_definition=$(aws ecs register-task-definition "${args[@]}")
  new_task_revision=$(read_task "$new_task_definition" 'revision')
  new_task_definition_family=$(read_task "$new_task_definition" 'family')

  # Making sure that we at least have one running task (even if desiredCount gets updated again with new task definition below)
  service_task_count=$(aws ecs describe-services --cluster "$CI_AWS_ECS_CLUSTER" --services "$CI_AWS_ECS_SERVICE" --query "services[0].desiredCount")

  if [[ $service_task_count == 0 ]]; then
    aws ecs update-service --cluster "$CI_AWS_ECS_CLUSTER" --service "$CI_AWS_ECS_SERVICE" --desired-count 1
  fi

  # Update ECS service with newly created task definition revision.
  aws ecs update-service \
            --cluster "$CI_AWS_ECS_CLUSTER" \
            --service "$CI_AWS_ECS_SERVICE" \
            --task-definition "$new_task_definition_family":"$new_task_revision"

  if [ -z "$CI_AWS_ECS_WAIT_FOR_ROLLOUT_COMPLETE_DISABLED" ]; then
    while [ "$(rollout_state)" == "IN_PROGRESS" ]
    do
      echo "Waiting for rollout..."
      sleep 60
    done

    echo "Rollout $(rollout_state)!"
  fi

  return 0
}

rollout_state() {
  aws ecs describe-services --cluster "$CI_AWS_ECS_CLUSTER" --services "$CI_AWS_ECS_SERVICE" | jq -r '.services[0].deployments[] | select(.status == "PRIMARY").rolloutState'
}

ensure_params() {
  if [ -z "$DOCKER_REGISTRY" ]; then
    echo "Please set up a DOCKER_REGISTRY variable to your CI job with the url of the docker registry you are using."
    exit 1
  fi

  if [ -z "$IMAGE_NAME" ]; then
    echo "Please set up a IMAGE_NAME variable to your CI job with the name of the docker image you are going to deploy."
    exit 1
  fi

  if [ -z "$CI_AWS_ECS_CLUSTER" ]; then
    echo "Please set up a CI_AWS_ECS_CLUSTER variable to your CI job with the name of the AWS ECS cluster your are targetting."
    exit 1
  fi

  if [ -z "$CI_AWS_ECS_SERVICE" ]; then
    echo "Please set up a CI_AWS_ECS_SERVICE variable to your CI job with the name of the service your AWS ECS cluster uses."
    exit 1
  fi

  if [ -z "$CI_AWS_ECS_TASK_DEFINITION" ]; then
    echo "Please set up a CI_AWS_ECS_TASK_DEFINITION variable to your CI job with the name of your AWS ECS task definition as a value."
    exit 1
  fi
}

ensure_service_if_fargate() {
  local service_launch_type

  service_launch_type=$(read_task "$1" "${register_task_def_args['requires-compatibilities']}")

  if [ "$AUTO_DEVOPS_PLATFORM_TARGET" == "FARGATE" ] && ! [[ "$service_launch_type" =~ "FARGATE" ]]; then
    echo "Compatibility error: the ECS service you are targeting is not a FARGATE launch type."
    exit 1
  fi
}

register_task_definition() {
  task=$(aws ecs describe-task-definition --task-definition "$CI_AWS_ECS_TASK_DEFINITION")

  ensure_service_if_fargate "$task"

  current_container_definitions=$(read_task "$task" 'containerDefinitions')

  if [ -z "$CI_AWS_ECS_CONTAINER_NAME" ]; then
    # Replace the image of the first container definition, if the container name is not specified
    new_container_definitions=$(echo "$current_container_definitions" | jq --arg val "$new_image_name" '.[0].image = $val')
  else
    # Replace the image of the specified container definition using the container name
    new_container_definitions=$(echo "$current_container_definitions" | jq --arg val "$new_image_name" --arg container_name "$CI_AWS_ECS_CONTAINER_NAME" '[.[] | select(.name==$container_name).image = $val]')
  fi

  args+=("--family" "${CI_AWS_ECS_TASK_DEFINITION}")
  args+=("--container-definitions" "${new_container_definitions}")

  for option in "${!register_task_def_args[@]}"; do
    value=$(read_task "$task" "${register_task_def_args[$option]}")
    if [ -n "$value" ];then
      args+=("--${option}" "${value}")
    fi
  done
}

read_task() {
  local val

  val=$(echo "$1" | jq -r ".taskDefinition.$2")

  if [ "$val" == "null" ];then
    val=$(echo "$1" | jq -r ".$2")
  fi

  if [ "$val" != "null" ];then
    echo -n "${val}"
  fi
}

option=$1
case $option in
  update-task-definition) update_task_definition ;;
  *) exit 1;;
esac
